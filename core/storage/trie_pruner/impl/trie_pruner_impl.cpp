/** * Copyright Soramitsu Co., Ltd. All Rights Reserved. * SPDX-License-Identifier: Apache-2.0 */#include "storage/trie_pruner/impl/trie_pruner_impl.hpp"#include <boost/assert.hpp>#include <queue>#include "application/app_configuration.hpp"#include "blockchain/block_storage.hpp"#include "blockchain/block_tree.hpp"#include "crypto/hasher/hasher_impl.hpp"#include "storage/database_error.hpp"#include "storage/spaced_storage.hpp"#include "storage/spaces.hpp"#include "storage/trie/polkadot_trie/polkadot_trie.hpp"#include "storage/trie/serialization/polkadot_codec.hpp"#include "storage/trie/serialization/trie_serializer.hpp"#include "storage/trie/trie_storage_backend.hpp"OUTCOME_CPP_DEFINE_CATEGORY(kagome::storage::trie_pruner,                            TriePrunerImpl::Error,                            e) {  using E = kagome::storage::trie_pruner::TriePrunerImpl::Error;  switch (e) {    case E::OUTDATED_PRUNE_BASE:      return "Attempt to create trie pruner on a database with outdated pruner "             "info record (most likely a corrupted database)";    case E::CREATE_PRUNER_ON_NON_PRUNED_NON_EMPTY_STORAGE:      return "Attempt to create trie pruner on a non-pruned non-empty database";  }  return "Unknown TriePruner error";}namespace kagome::storage::trie_pruner {  outcome::result<std::unique_ptr<TriePrunerImpl>> TriePrunerImpl::create(      std::shared_ptr<const application::AppConfiguration> config,      std::shared_ptr<storage::trie::TrieStorageBackend> trie_storage,      std::shared_ptr<const storage::trie::TrieSerializer> serializer,      std::shared_ptr<const storage::trie::Codec> codec,      std::shared_ptr<storage::SpacedStorage> storage,      std::shared_ptr<const crypto::Hasher> hasher) {    auto pruner = std::unique_ptr<TriePrunerImpl>(        new TriePrunerImpl{config->statePruningDepth(),                           trie_storage,                           serializer,                           codec,                           storage,                           hasher});    BOOST_ASSERT(storage->getSpace(kTriePruner));    OUTCOME_TRY(encoded_info,                storage->getSpace(kTriePruner)->tryGet(TRIE_PRUNER_INFO_KEY));    if (encoded_info.has_value()) {      OUTCOME_TRY(info, scale::decode<TriePrunerInfo>(*encoded_info));      pruner->base_block_ = info.prune_base;      pruner->child_states_.insert(info.child_states.begin(),                                   info.child_states.end());    }    return pruner;  }  template <typename F>  static outcome::result<common::Buffer> calcMerkleValue(      const trie::Codec &codec,      const trie::OpaqueTrieNode &node,      std::optional<trie::StateVersion> version,      const F &child_visitor) {    OUTCOME_TRY(hash, codec.merkleValue(node, version, child_visitor));    return hash;  }  static outcome::result<common::Buffer> calcHash(      const trie::Codec &codec,      const trie::TrieNode &node,      std::optional<trie::StateVersion> version) {    OUTCOME_TRY(        enc,        codec.encodeNode(            node, version, [](auto &, auto, auto &&) -> outcome::result<void> {              return outcome::success();            }));    auto hash = codec.hash256(enc);    return hash;  }  struct EncoderCache {    explicit EncoderCache(trie::Codec const &codec) : codec{codec} {}    std::unordered_map<trie::OpaqueTrieNode const *, common::Buffer> enc_cache;    trie::Codec const &codec;    outcome::result<void> visitChild(trie::OpaqueTrieNode const &node,                                     common::BufferView merkle_value) {      enc_cache[&node] = merkle_value;      return outcome::success();    }    outcome::result<common::Buffer> getMerkleValue(        trie::OpaqueTrieNode const &node,        std::optional<trie::StateVersion> version) {      if (auto it = enc_cache.find(&node); it != enc_cache.end()) {        SL_INFO(logger, "Cache hit {} = {}", fmt::ptr(&node), it->second.toHex());        OUTCOME_TRY(hash,                    calcMerkleValue(codec,                                    node,                                    version,                                    [](auto &node, auto merkle_value, auto)                                        -> outcome::result<void> {                                      // return visitChild(node, merkle_value);                                      return outcome::success();                                    }));        if (it->second.toHex() == "5f0dcb0c5143a8617ed38ae3810dd45bc61000000000") {        }        BOOST_ASSERT(hash == it->second);        return it->second;      } else {        OUTCOME_TRY(hash,                    calcMerkleValue(codec,                                    node,                                    version,                                    [](auto &node, auto merkle_value, auto)                                        -> outcome::result<void> {                                      // return visitChild(node, merkle_value);                                      return outcome::success();                                    }));        SL_INFO(logger, "Cache miss {} = {}", fmt::ptr(&node), hash.toHex());        enc_cache[&node] = hash;        if (hash.toHex() == "5f0dcb0c5143a8617ed38ae3810dd45bc61000000000") {        }        return hash;      }    }    log::Logger logger = log::createLogger("PrunerCache");  };  outcome::result<void> TriePrunerImpl::init(      const blockchain::BlockTree &block_tree) {    if (base_block_.number == 0) {      OUTCOME_TRY(first_hash_opt, block_tree.getBlockHash(1));      if (first_hash_opt.has_value()) {        SL_WARN(logger_,                "Running pruner on a non-empty non-pruned storage may lead to "                "performance degradation for the next prune.");        OUTCOME_TRY(            genesis,            block_tree.getBlockHeader(block_tree.getGenesisBlockHash()));        if (auto res = restoreState(genesis, block_tree); res.has_error()) {          SL_ERROR(logger_,                   "Failed to restore trie pruner state starting from genesis "                   "block: {}",                   res.error().message());          return res;        }      }    } else {      OUTCOME_TRY(base_block_header,                  block_tree.getBlockHeader(base_block_.hash));      BOOST_ASSERT(block_tree.getLastFinalized().number >= base_block_.number);      if (auto res = restoreState(base_block_header, block_tree);          res.has_error()) {        SL_WARN(logger_,                "Failed to restore trie pruner state starting from base "                "block {}: {}",                base_block_,                res.error().message());        return outcome::success();      }    }    return outcome::success();  }  outcome::result<void> TriePrunerImpl::pruneFinalized(      primitives::BlockHeader const &block,      primitives::BlockInfo const &next_block) {    BOOST_ASSERT(next_block.number == block.number + 1);    OUTCOME_TRY(prune(block));    base_block_ = next_block;    OUTCOME_TRY(savePersistentState());    return outcome::success();  }  outcome::result<void> TriePrunerImpl::pruneDiscarded(      primitives::BlockHeader const &block) {    OUTCOME_TRY(prune(block));    return outcome::success();  }  outcome::result<void> TriePrunerImpl::prune(      primitives::BlockHeader const &block) {    auto trie_res = serializer_->retrieveTrie(block.state_root, nullptr);    if (trie_res.has_error()        && trie_res.error() == storage::DatabaseError::NOT_FOUND) {      SL_TRACE(logger_,               "Failed to obtain trie from storage, the block {} is probably "               "already pruned "               "or never has been executed.",               block.number);      return outcome::success();    }    KAGOME_PROFILE_START_L(logger_, prune_state);    OUTCOME_TRY(trie, trie_res);    if (trie->getRoot() == nullptr) {      SL_DEBUG(logger_, "Attempt to prune a trie with a null root");      return outcome::success();    }    size_t removed = 0;    size_t unknown = 0;    struct Entry {      std::shared_ptr<trie::TrieNode> node;      size_t depth;    };    std::vector<Entry> queued_nodes;    queued_nodes.push_back({trie->getRoot(), 0});    EncoderCache encoder{*codec_};    OUTCOME_TRY(root_value,                encoder.getMerkleValue(*trie->getRoot(), std::nullopt));    OUTCOME_TRY(root_hash, calcHash(*codec_, *trie->getRoot(), std::nullopt));    logger_->info("Prune: Merkle value of state {} (#{} - state_root {}) is {}",                  root_hash,                  block.number,                  block.state_root,                  root_value);    auto batch = trie_storage_->batch();    // iterate nodes, decrement their ref count and delete if ref count becomes    // zero    while (!queued_nodes.empty()) {      auto [node, depth] = queued_nodes.back();      queued_nodes.pop_back();      // FIXME: crutch because root nodes are always hashed, so encoding      // doesn't match here and in addState (which always just takes merkle      // value)      OUTCOME_TRY(merkle_value, encoder.getMerkleValue(*node, std::nullopt));      auto ref_count_it = ref_count_.find(merkle_value);      if (ref_count_it == ref_count_.end()) {        unknown++;        continue;      }      auto &ref_count = ref_count_it->second;      BOOST_ASSERT(ref_count != 0);      ref_count--;      SL_TRACE(logger_,               "Prune - {} - Node {}, ref count {}",               depth,               merkle_value,               ref_count);      if (ref_count == 0) {        removed++;        ref_count_.erase(merkle_value);        OUTCOME_TRY(batch->remove(merkle_value));        if (node->isBranch()) {          auto branch = static_cast<const trie::BranchNode &>(*node);          for (auto opaque_child : branch.children) {            if (opaque_child != nullptr) {              OUTCOME_TRY(child_merkle_value,                          encoder.getMerkleValue(*opaque_child, std::nullopt));              SL_TRACE(logger_, "Prune - Child {}", child_merkle_value);              OUTCOME_TRY(child,                          serializer_->retrieveNode(opaque_child, nullptr));              queued_nodes.push_back({child, depth + 1});            }          }        }      }    }    OUTCOME_TRY(batch->commit());    SL_DEBUG(logger_, "Removed {} nodes, {} unknown", removed, unknown);    return outcome::success();  }  outcome::result<void> TriePrunerImpl::addNewState(      trie::PolkadotTrie const &new_trie, trie::StateVersion version) {    OUTCOME_TRY(addNewStateWith(new_trie,                                version,                                AddConfig{                                    .type = AddConfig::AddLoadedOnly,                                }));    OUTCOME_TRY(savePersistentState());    return outcome::success();  }  outcome::result<void> TriePrunerImpl::addNewChildState(      storage::trie::RootHash const &parent_root,      trie::PolkadotTrie const &new_trie,      trie::StateVersion version) {    OUTCOME_TRY(child_root_hash,                addNewStateWith(new_trie,                                version,                                AddConfig{                                    .type = AddConfig::AddLoadedOnly,                                }));    OUTCOME_TRY(markAsChild(Parent{parent_root}, Child{child_root_hash}));    return outcome::success();  }  outcome::result<void> TriePrunerImpl::markAsChild(Parent parent,                                                    Child child) {    child_states_[parent.hash].emplace_back(child.hash);    OUTCOME_TRY(savePersistentState());    return outcome::success();  }  outcome::result<storage::trie::RootHash> TriePrunerImpl::addNewStateWith(      trie::PolkadotTrie const &new_trie,      trie::StateVersion version,      AddConfig config) {    if (new_trie.getRoot() == nullptr) {      SL_DEBUG(logger_, "Attempt to add a trie with a null root");      return outcome::success();    }    SL_DEBUG(logger_, "Ref count map size is {}", ref_count_.size());    KAGOME_PROFILE_START_L(logger_, register_state);    std::vector<std::shared_ptr<const trie::OpaqueTrieNode>> queued_nodes;    queued_nodes.push_back(new_trie.getRoot());    EncoderCache encoder{*codec_};    OUTCOME_TRY(root_value,                encoder.getMerkleValue(*new_trie.getRoot(), version));    OUTCOME_TRY(root_hash, calcHash(*codec_, *new_trie.getRoot(), version));    ref_count_[root_value] += 1;    logger_->info("Add: Merkle value of state {} is {}", root_hash, root_value);    size_t referenced_nodes_num = 0;    while (!queued_nodes.empty()) {      auto opaque_node = queued_nodes.back();      queued_nodes.pop_back();      OUTCOME_TRY(hash, encoder.getMerkleValue(*opaque_node, version));      SL_TRACE(logger_,               "Add - Node {}, ref count {}",               hash.toHex(),               ref_count_[hash]);      referenced_nodes_num++;      if (auto node = dynamic_cast<trie::TrieNode const *>(opaque_node.get());          node != nullptr && node->isBranch()          && (config.shouldAddAllNodes() || ref_count_[hash] == 1)) {        auto branch = static_cast<const trie::BranchNode *>(opaque_node.get());        for (auto opaque_child : branch->children) {          if (opaque_child != nullptr) {            OUTCOME_TRY(child_hash,                        encoder.getMerkleValue(*opaque_child, version));            ref_count_[child_hash] += 1;            SL_TRACE(logger_, "Add - Child {}", child_hash.toHex());            if (config.shouldLoadDummies()) {              OUTCOME_TRY(child, serializer_->retrieveNode(opaque_child));              queued_nodes.push_back(child);            } else {              queued_nodes.push_back(opaque_child);            }          }        }      }    }    SL_DEBUG(logger_,             "Referenced {} nodes\nRef count map size: {}",             referenced_nodes_num,             ref_count_.size());    return common::Hash256::fromSpan(root_hash);  }  outcome::result<void> TriePrunerImpl::restoreState(      primitives::BlockHeader const &base_block,      blockchain::BlockTree const &block_tree) {    KAGOME_PROFILE_START_L(logger_, restore_state);    SL_DEBUG(logger_, "Restore state - base block #{}", base_block.number);    ref_count_.clear();    crypto::HasherImpl hasher;    auto base_tree_res = serializer_->retrieveTrie(base_block.state_root);    if (base_tree_res.has_error()        && base_tree_res.error() == storage::DatabaseError::NOT_FOUND) {      SL_DEBUG(          logger_,          "Failed to restore pruner state, probably node is fast-syncing.");      return outcome::success();    }    OUTCOME_TRY(base_tree, std::move(base_tree_res));    OUTCOME_TRY(addNewStateWith(*base_tree,                                trie::StateVersion::V0,                                AddConfig{.type = AddConfig::AddWholeState}));    std::queue<primitives::BlockHash> block_queue;    OUTCOME_TRY(base_enc, scale::encode(base_block));    auto base_hash = hasher_->blake2b_256(base_enc);    {      OUTCOME_TRY(children, block_tree.getChildren(base_hash));      for (auto child : children) {        block_queue.push(child);      }    }    while (!block_queue.empty()) {      auto block_hash = block_queue.front();      OUTCOME_TRY(header, block_tree.getBlockHeader(block_hash));      SL_DEBUG(logger_,               "Restore state - register #{} ()",               header.number,               block_hash);      OUTCOME_TRY(tree, serializer_->retrieveTrie(header.state_root));      OUTCOME_TRY(          addNewStateWith(*tree,                          trie::StateVersion::V0,                          AddConfig{.type = AddConfig::AddNewLoadDummies}));      block_queue.pop();      OUTCOME_TRY(children, block_tree.getChildren(block_hash));      for (auto child : children) {        block_queue.push(child);      }    }    base_block_ = {base_block.number, base_hash};    OUTCOME_TRY(savePersistentState());    return outcome::success();  }  outcome::result<void> TriePrunerImpl::savePersistentState() const {    std::vector<        std::pair<primitives::BlockHash, std::vector<storage::trie::RootHash>>>        child_states;    std::copy(child_states_.begin(),              child_states_.end(),              std::back_inserter(child_states));    OUTCOME_TRY(enc_info,                scale::encode(TriePrunerInfo{                    base_block_,                    child_states,                }));    BOOST_ASSERT(storage_->getSpace(kTriePruner));    OUTCOME_TRY(        storage_->getSpace(kTriePruner)            ->put(TRIE_PRUNER_INFO_KEY, common::Buffer{std::move(enc_info)}));    return outcome::success();  }}  // namespace kagome::storage::trie_pruner