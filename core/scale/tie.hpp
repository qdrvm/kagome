/**
 * Copyright Quadrivium LLC
 * All Rights Reserved
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once

#include <scale/scale_decoder_stream.hpp>
#include <span>
#include <tuple>

#define SCALE_TIE_EQ                                             \
  template <typename _ScaleTieType>                              \
  bool operator==(const _ScaleTieType &r) const {                \
    using ThisT = std::decay_t<decltype(*this)>;                 \
    using ExtT = std::decay_t<_ScaleTieType>;                    \
    static_assert(std::is_same_v<ExtT, ThisT>                    \
                  || std::is_base_of_v<ThisT, ExtT>);            \
    return ::scale::as_tie(*this, [&](auto l) {                  \
      return ::scale::as_tie(r, [&](auto r) { return l == r; }); \
    });                                                          \
  }                                                              \
  template <typename _ScaleTieType>                              \
  bool operator!=(const _ScaleTieType &r) const {                \
    return !operator==(r);                                       \
  }

#define SCALE_TIE_ONLY(...)                       \
  auto as_tie() { return std::tie(__VA_ARGS__); } \
  SCALE_TIE_EQ

#define SCALE_TIE(N)                     \
  static constexpr size_t scale_tie = N; \
  SCALE_TIE_EQ

namespace scale {
  class ScaleEncoderStream;
  class ScaleDecoderStream;

  template <typename T,
            typename F,
            typename = decltype(std::declval<std::remove_const_t<
                                    std::remove_reference_t<T>>>()
                                    .as_tie())>
  auto as_tie(T &&v, F &&f) {
    return f(const_cast<std::remove_const_t<std::remove_reference_t<T>> &>(v)
                 .as_tie());
  }

  // generated by housekeeping/scale_tie.py
  template <typename T,
            typename F,
            size_t N = std::remove_reference_t<T>::scale_tie>
  auto as_tie(T &&v, F &&f) {
    if constexpr (N == 0) {
      return std::tie();
    } else if constexpr (N == 1) {
      auto &[v0] = v;
      return std::forward<F>(f)(std::tie(v0));
    } else if constexpr (N == 2) {
      auto &[v0, v1] = v;
      return std::forward<F>(f)(std::tie(v0, v1));
    } else if constexpr (N == 3) {
      auto &[v0, v1, v2] = v;
      return std::forward<F>(f)(std::tie(v0, v1, v2));
    } else if constexpr (N == 4) {
      auto &[v0, v1, v2, v3] = v;
      return std::forward<F>(f)(std::tie(v0, v1, v2, v3));
    } else if constexpr (N == 5) {
      auto &[v0, v1, v2, v3, v4] = v;
      return std::forward<F>(f)(std::tie(v0, v1, v2, v3, v4));
    } else if constexpr (N == 6) {
      auto &[v0, v1, v2, v3, v4, v5] = v;
      return std::forward<F>(f)(std::tie(v0, v1, v2, v3, v4, v5));
    } else if constexpr (N == 7) {
      auto &[v0, v1, v2, v3, v4, v5, v6] = v;
      return std::forward<F>(f)(std::tie(v0, v1, v2, v3, v4, v5, v6));
    } else if constexpr (N == 8) {
      auto &[v0, v1, v2, v3, v4, v5, v6, v7] = v;
      return std::forward<F>(f)(std::tie(v0, v1, v2, v3, v4, v5, v6, v7));
    } else if constexpr (N == 9) {
      auto &[v0, v1, v2, v3, v4, v5, v6, v7, v8] = v;
      return std::forward<F>(f)(std::tie(v0, v1, v2, v3, v4, v5, v6, v7, v8));
    } else if constexpr (N == 10) {
      auto &[v0, v1, v2, v3, v4, v5, v6, v7, v8, v9] = v;
      return std::forward<F>(f)(
          std::tie(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9));
    } else if constexpr (N == 11) {
      auto &[v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10] = v;
      return std::forward<F>(f)(
          std::tie(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10));
    } else if constexpr (N == 12) {
      auto &[v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11] = v;
      return std::forward<F>(f)(
          std::tie(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11));
    } else if constexpr (N == 13) {
      auto &[v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12] = v;
      return std::forward<F>(f)(
          std::tie(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12));
    } else if constexpr (N == 14) {
      auto &[v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13] = v;
      return std::forward<F>(f)(
          std::tie(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13));
    } else if constexpr (N == 15) {
      auto &[v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14] =
          v;
      return std::forward<F>(f)(std::tie(
          v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14));
    } else {
      // generate code for bigger tuples
      BOOST_STATIC_ASSERT_MSG(N > 15, "No code for such big tuple");
    }
  }

  constexpr auto as_tie_sfinae = [](auto &&) {};

  template <typename T,
            typename = decltype(scale::as_tie(std::declval<T>(),
                                              as_tie_sfinae))>
  ScaleEncoderStream &operator<<(ScaleEncoderStream &s, const T &v) {
    as_tie(v, [&](auto v) {
      std::apply([&](const auto &...v) { (..., (s << v)); }, v);
    });
    return s;
  }

  template <typename T,
            typename = decltype(scale::as_tie(std::declval<T>(),
                                              as_tie_sfinae))>
  ScaleDecoderStream &operator>>(ScaleDecoderStream &s, T &v) {
    as_tie(v, [&](auto v) {
      std::apply([&](auto &...v) { (..., (s >> v)); }, v);
    });
    return s;
  }

}  // namespace scale
