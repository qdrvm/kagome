/**
 * Copyright Soramitsu Co., Ltd. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

#ifndef KAGOME_UTILS_SCALE_TUPLE_HPP
#define KAGOME_UTILS_SCALE_TUPLE_HPP

#include <tuple>

#define SCALE_TIE(N) static constexpr size_t scale_tie = N
#define SCALE_TIE_EQ(T)                                       \
  bool operator==(const T &r) const {                         \
    static_assert(std::is_same_v<const T *, decltype(this)>); \
    return ::scale::as_tie(*this) == ::scale::as_tie(r);      \
  }                                                           \
  bool operator!=(const T &r) const {                         \
    static_assert(std::is_same_v<const T *, decltype(this)>); \
    return !operator==(r);                                    \
  }

namespace scale {
  class ScaleEncoderStream;
  class ScaleDecoderStream;

  // generated by housekeeping/scale_tie.py
  template <typename T, size_t N = std::remove_reference_t<T>::scale_tie>
  auto as_tie(T &&v) {
    if constexpr (N == 0) {
      // can't create zero sized binding to check zero size
      return std::tie();
    } else if constexpr (N == 1) {
      auto &[v0] = v;
      return std::tie(v0);
    } else if constexpr (N == 2) {
      auto &[v0, v1] = v;
      return std::tie(v0, v1);
    } else if constexpr (N == 3) {
      auto &[v0, v1, v2] = v;
      return std::tie(v0, v1, v2);
    } else if constexpr (N == 4) {
      auto &[v0, v1, v2, v3] = v;
      return std::tie(v0, v1, v2, v3);
    } else if constexpr (N == 5) {
      auto &[v0, v1, v2, v3, v4] = v;
      return std::tie(v0, v1, v2, v3, v4);
    } else if constexpr (N == 6) {
      auto &[v0, v1, v2, v3, v4, v5] = v;
      return std::tie(v0, v1, v2, v3, v4, v5);
    } else {
      // generate code for bigger tuples
      (void)0;
    }
  }

  template <typename T, size_t = T::scale_tie>
  ScaleEncoderStream &operator<<(ScaleEncoderStream &s, const T &v) {
    s << as_tie(v);
    return s;
  }

  template <size_t I, class... Ts>
  void decode_tie(ScaleDecoderStream &s, const std::tuple<Ts...> &v) {
    if constexpr (sizeof...(Ts) > I) {
      s >> std::get<I>(v);
      decode_tie<I + 1>(s, v);
    }
  }

  template <typename T, size_t = T::scale_tie>
  ScaleDecoderStream &operator>>(ScaleDecoderStream &s, T &v) {
    decode_tie<0>(s, as_tie(v));
    return s;
  }
}  // namespace scale

#endif  // KAGOME_UTILS_SCALE_TUPLE_HPP
