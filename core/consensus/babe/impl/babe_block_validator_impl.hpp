/**
 * Copyright Quadrivium LLC
 * All Rights Reserved
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once

#include "consensus/babe/babe_block_validator.hpp"

#include "clock/clock.hpp"
#include "consensus/babe/types/babe_configuration.hpp"
#include "consensus/babe/types/slot_leadership.hpp"
#include "injector/lazy.hpp"
#include "log/logger.hpp"
#include "metrics/metrics.hpp"
#include "primitives/block.hpp"
#include "primitives/event_types.hpp"
#include "telemetry/service.hpp"

namespace kagome::application {
  class AppStateManager;
}

namespace kagome::consensus {
  class SlotsUtil;
}

namespace kagome::consensus::babe {
  class BabeConfigRepository;
  struct Seal;
}  // namespace kagome::consensus::babe

namespace kagome::crypto {
  class Hasher;
  class Sr25519Provider;
  class VRFProvider;
}  // namespace kagome::crypto

namespace kagome::runtime {
  class BabeApi;
}

namespace kagome::consensus::babe {

  class BabeBlockValidatorImpl
      : public BabeBlockValidator,
        public std::enable_shared_from_this<BabeBlockValidatorImpl> {
   public:
    BabeBlockValidatorImpl(
        std::shared_ptr<application::AppStateManager> app_state_manager,
        LazySPtr<SlotsUtil> slots_util,
        std::shared_ptr<BabeConfigRepository> config_repo,
        std::shared_ptr<crypto::Hasher> hasher,
        std::shared_ptr<crypto::Sr25519Provider> sr25519_provider,
        std::shared_ptr<crypto::VRFProvider> vrf_provider,
        std::shared_ptr<runtime::BabeApi> babe_api,
        primitives::events::SyncStateSubscriptionEnginePtr
            sync_state_observable);

    void prepare();

    outcome::result<void> validateHeader(
        const primitives::BlockHeader &block_header) const;

    enum class ValidationError {
      NO_VALIDATOR = 1,
      DISABLED_VALIDATOR,
      INVALID_SIGNATURE,
      INVALID_VRF,
      TWO_BLOCKS_IN_SLOT,
      SECONDARY_SLOT_ASSIGNMENTS_DISABLED
    };

   private:
    /**
     * Validate the block header
     * @param block to be validated
     * @param authority_id authority that sent this block
     * @param threshold is vrf threshold for this epoch
     * @param config is babe config for this epoch
     * @return nothing or validation error
     */
    outcome::result<void> validateHeader(
        const primitives::BlockHeader &block_header,
        const EpochNumber epoch_number,
        const babe::AuthorityId &authority_id,
        const Threshold &threshold,
        const babe::BabeConfiguration &config) const;
    /**
     * Verify that block is signed by valid signature
     * @param header Header to be checked
     * @param seal Seal corresponding to (fetched from) header
     * @param public_key public key that corresponds to the authority by
     * authority index
     * @return true if signature is valid, false otherwise
     */
    bool verifySignature(const primitives::BlockHeader &header,
                         const Seal &seal,
                         const AuthorityId &public_key) const;

    /**
     * Verify that vrf value contained in babe_header is less than threshold and
     * was generated by the creator of the block
     * @param babe_header BabeBlockHeader corresponding to (fetched from) header
     * @param public_key Public key of creator of the block
     * @param threshold threshold value for that epoch
     * @param randomness randomness for that epoch
     * @return true if vrf is valid, false otherwise
     */
    bool verifyVRF(const BabeBlockHeader &babe_header,
                   const EpochNumber epoch_number,
                   const babe::AuthorityId &public_key,
                   const Threshold &threshold,
                   const Randomness &randomness,
                   const bool checkThreshold) const;

    log::Logger log_;

    LazySPtr<SlotsUtil> slots_util_;
    std::shared_ptr<BabeConfigRepository> config_repo_;
    std::shared_ptr<crypto::Hasher> hasher_;
    std::shared_ptr<crypto::Sr25519Provider> sr25519_provider_;
    std::shared_ptr<crypto::VRFProvider> vrf_provider_;
    std::shared_ptr<runtime::BabeApi> babe_api_;
    primitives::events::SyncStateSubscriptionEnginePtr sync_state_observable_;

    bool was_synchronized_ = false;
    primitives::events::SyncStateEventSubscriberPtr sync_state_observer_;
  };

}  // namespace kagome::consensus::babe

OUTCOME_HPP_DECLARE_ERROR(kagome::consensus::babe,
                          BabeBlockValidatorImpl::ValidationError)
