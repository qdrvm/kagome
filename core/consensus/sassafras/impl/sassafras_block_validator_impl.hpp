/**
 * Copyright Quadrivium LLC
 * All Rights Reserved
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once

#include "consensus/sassafras/sassafras_block_validator.hpp"

#include "clock/clock.hpp"
#include "consensus/sassafras/types/sassafras_configuration.hpp"
#include "consensus/sassafras/types/slot_leadership.hpp"
#include "injector/lazy.hpp"
#include "log/logger.hpp"
#include "metrics/metrics.hpp"
#include "primitives/block.hpp"
#include "primitives/event_types.hpp"
#include "telemetry/service.hpp"

namespace kagome::consensus {
  class SlotsUtil;
}

namespace kagome::consensus::sassafras {
  class SassafrasConfigRepository;
  struct Seal;
}  // namespace kagome::consensus::sassafras

namespace kagome::crypto {
  class Hasher;
  class Sr25519Provider;
  class VRFProvider;
}  // namespace kagome::crypto

namespace kagome::consensus::sassafras {

  class SassafrasBlockValidatorImpl
      : public SassafrasBlockValidator,
        public std::enable_shared_from_this<SassafrasBlockValidatorImpl> {
   public:
    SassafrasBlockValidatorImpl(
        LazySPtr<SlotsUtil> slots_util,
        std::shared_ptr<SassafrasConfigRepository> config_repo,
        std::shared_ptr<crypto::Hasher> hasher,
        std::shared_ptr<crypto::Sr25519Provider> sr25519_provider,
        std::shared_ptr<crypto::VRFProvider> vrf_provider);

    outcome::result<void> validateHeader(
        const primitives::BlockHeader &block_header) const;

    enum class ValidationError {
      NO_AUTHORITIES = 1,
      INVALID_SIGNATURE,
      INVALID_VRF,
      TWO_BLOCKS_IN_SLOT,
      SECONDARY_SLOT_ASSIGNMENTS_DISABLED
    };

   private:
    /**
     * Validate the block header
     * @param block to be validated
     * @param authority_id authority that sent this block
     * @param threshold is vrf threshold for this epoch
     * @param config is sassafras config for this epoch
     * @return nothing or validation error
     */
    outcome::result<void> validateHeader(
        const primitives::BlockHeader &block_header,
        const EpochNumber epoch_number,
        const sassafras::AuthorityId &authority_id,
        const Threshold &threshold,
        const sassafras::SassafrasConfiguration &config) const;
    /**
     * Verify that block is signed by valid signature
     * @param header Header to be checked
     * @param seal Seal corresponding to (fetched from) header
     * @param public_key public key that corresponds to the authority by
     * authority index
     * @return true if signature is valid, false otherwise
     */
    bool verifySignature(const primitives::BlockHeader &header,
                         const Seal &seal,
                         const AuthorityId &public_key) const;

    /**
     * Verify that vrf value contained in sassafras_header is less than
     * threshold and was generated by the creator of the block
     * @param sassafras_header SassafrasBlockHeader corresponding to (fetched
     * from) header
     * @param public_key Public key of creator of the block
     * @param threshold threshold value for that epoch
     * @param randomness randomness for that epoch
     * @return true if vrf is valid, false otherwise
     */
    bool verifyVRF(const SassafrasBlockHeader &sassafras_header,
                   const EpochNumber epoch_number,
                   const sassafras::AuthorityId &public_key,
                   const Threshold &threshold,
                   const Randomness &randomness,
                   const bool checkThreshold) const;

    log::Logger log_;

    LazySPtr<SlotsUtil> slots_util_;
    std::shared_ptr<SassafrasConfigRepository> config_repo_;
    std::shared_ptr<crypto::Hasher> hasher_;
    std::shared_ptr<crypto::Sr25519Provider> sr25519_provider_;
    std::shared_ptr<crypto::VRFProvider> vrf_provider_;
  };

}  // namespace kagome::consensus::sassafras

OUTCOME_HPP_DECLARE_ERROR(kagome::consensus::sassafras,
                          SassafrasBlockValidatorImpl::ValidationError)
