/**
 * Copyright Soramitsu Co., Ltd. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

#include <gtest/gtest.h>
#include <outcome/outcome.hpp>

#include "common/buffer.hpp"
#include "libp2p/crypto/common.hpp"
#include "libp2p/crypto/impl/crypto_provider_impl.hpp"

using kagome::common::Buffer;
using namespace libp2p::crypto;

class HmacFixture : public testing::Test {
 public:
  HmacFixture() {
    CryptoProviderImpl::initializeOpenSSL();

    // 55cd433be9568ee79525a0919cf4b31c28108cee
    sha1_key = {0x55, 0xcd, 0x43, 0x3b, 0xe9, 0x56, 0x8e,
                0xe7, 0x95, 0x25, 0xa0, 0x91, 0x9c, 0xf4,
                0xb3, 0x1c, 0x28, 0x10, 0x8c, 0xee};  // 20 bytes

    // a1990aeb68efb1b59d3165795f6338960aa7238ba74779ea5df3a435fdbb
    // 8d4c
    sha256_key = {0xa1, 0x99, 0x0a, 0xeb, 0x68, 0xef, 0xb1, 0xb5,
                  0x9d, 0x31, 0x65, 0x79, 0x5f, 0x63, 0x38, 0x96,
                  0x0a, 0xa7, 0x23, 0x8b, 0xa7, 0x47, 0x79, 0xea,
                  0x5d, 0xf3, 0xa4, 0x35, 0xfd, 0xbb, 0x8d, 0x4c};  // 32 bytes

    // dd114c7351b2186aeba2d3fb4d96496da9e1681ae6272df553a8235a05e6
    // f1ae66d5c4efa32cdfbf1b0f3b9542c14444a523859cde43736c7b5b8998
    // 03d1a96a
    sha512_key = {
        0xdd, 0x11, 0x4c, 0x73, 0x51, 0xb2, 0x18, 0x6a, 0xeb, 0xa2,  // 64 bytes
        0xd3, 0xfb, 0x4d, 0x96, 0x49, 0x6d, 0xa9, 0xe1, 0x68, 0x1a, 0xe6,
        0x27, 0x2d, 0xf5, 0x53, 0xa8, 0x23, 0x5a, 0x05, 0xe6, 0xf1, 0xae,
        0x66, 0xd5, 0xc4, 0xef, 0xa3, 0x2c, 0xdf, 0xbf, 0x1b, 0x0f, 0x3b,
        0x95, 0x42, 0xc1, 0x44, 0x44, 0xa5, 0x23, 0x85, 0x9c, 0xde, 0x43,
        0x73, 0x6c, 0x7b, 0x5b, 0x89, 0x98, 0x03, 0xd1, 0xa9, 0x6a};

    // use the same message for all tests
    message.put("The fly got to the jam that's all the poem");

    sha1_dgst = {0x92, 0xd1, 0xc3, 0xb5, 0x5f, 0xad, 0xa7,
                 0x1c, 0x07, 0x88, 0x67, 0x75, 0xcf, 0x77,
                 0xb6, 0x95, 0xea, 0xd0, 0xe8, 0x1a};  // 20 bytes
    // ffe54d22fc47df26bb8e62c41f569b8feec06454e83efb01961ea22f45b03d76
    sha256_dgst = {0xff, 0xe5, 0x4d, 0x22, 0xfc, 0x47, 0xdf, 0x26,
                   0xbb, 0x8e, 0x62, 0xc4, 0x1f, 0x56, 0x9b, 0x8f,
                   0xee, 0xc0, 0x64, 0x54, 0xe8, 0x3e, 0xfb, 0x01,
                   0x96, 0x1e, 0xa2, 0x2f, 0x45, 0xb0, 0x3d, 0x76};

    // 03409ea5a9e8d8e2dc89ef9d9cc6c7d9d342247f4a273cedc60f81fb9348
    // 926792a2718fd215dbb0b473662a3d33ec28ed1b2aa4268797438be069f2
    // fca95559
    sha512_dgst = {0x03, 0x40, 0x9e, 0xa5, 0xa9, 0xe8, 0xd8, 0xe2, 0xdc, 0x89,
                   0xef, 0x9d, 0x9c, 0xc6, 0xc7, 0xd9, 0xd3, 0x42, 0x24, 0x7f,
                   0x4a, 0x27, 0x3c, 0xed, 0xc6, 0x0f, 0x81, 0xfb, 0x93, 0x48,
                   0x92, 0x67, 0x92, 0xa2, 0x71, 0x8f, 0xd2, 0x15, 0xdb, 0xb0,
                   0xb4, 0x73, 0x66, 0x2a, 0x3d, 0x33, 0xec, 0x28, 0xed, 0x1b,
                   0x2a, 0xa4, 0x26, 0x87, 0x97, 0x43, 0x8b, 0xe0, 0x69, 0xf2,
                   0xfc, 0xa9, 0x55, 0x59};
  }

  Buffer sha1_key;
  Buffer sha256_key;
  Buffer sha512_key;
  Buffer message;
  Buffer sha1_dgst;
  Buffer sha256_dgst;
  Buffer sha512_dgst;
};

/**
 * @given 20 bytes key, default message
 * @when hmacDigest is applied with hash = kSha1
 * @then obtained digest matches predefined one
 */
TEST_F(HmacFixture, hashSha1) {
  CryptoProviderImpl provider{};
  auto &&digest =
      provider.hmacDigest(common::HashType::kSHA1, sha1_key, message);
  ASSERT_TRUE(digest);
  ASSERT_EQ(digest.value().size(), 20);
  std::cout << "hmac = " << digest.value().toHex() << std::endl;
  ASSERT_EQ(digest.value(), sha1_dgst);
}

/**
 * @given 32 bytes key, default message
 * @when hmacDigest is applied with hash = kSha256
 * @then obtained digest matches predefined one
 */
TEST_F(HmacFixture, hashSha256) {
  CryptoProviderImpl provider{};
  auto &&digest =
      provider.hmacDigest(common::HashType::kSHA256, sha256_key, message);
  ASSERT_TRUE(digest);
  ASSERT_EQ(digest.value().size(), 32);
  std::cout << "hmac = " << digest.value().toHex() << std::endl;
  ASSERT_EQ(digest.value(), sha256_dgst);
}

/**
 * @given 64 bytes key, default message
 * @when hmacDigest is applied with hash = kSha512
 * @then obtained digest matches predefined one
 */
TEST_F(HmacFixture, hashSha512) {
  CryptoProviderImpl provider{};
  auto &&digest =
      provider.hmacDigest(common::HashType::kSHA512, sha512_key, message);
  ASSERT_TRUE(digest);
  ASSERT_EQ(digest.value().size(), 64);
  std::cout << "hmac = " << digest.value().toHex() << std::endl;
  ASSERT_EQ(digest.value(), sha512_dgst);
}
